  单一职责原则	一个类只负责一项职责	设计模式的六大原则	17种设计模式的学习
	开闭原则	对扩展开放，对修改关闭（尽量不修改已有代码）		
	里氏替换原则	子类可以扩展父类的功能，但不能改变父类原有的功能		
	依赖倒置原则	面向接口编程		
	接口隔离原则	设计接口功能尽量细粒度，最小功能单元		
	迪米特法则	降低耦合（局部变量中，不要引入新的类）		

  简单工厂模式	用一个专业的类（工厂类）来负责一种产品对象的创建	是工厂模式的基础/不符合单一职责，开闭两项原则，	5种创建型模式（kotlin代码）
	工厂方法模式	扩展新的品类时，不要修改已有代码	很好用，方便扩展/新增包装工厂时，工厂之间容易出错，不方便管理	
	抽象工厂模式	当一个类别的产品还有多个系列区分时，为了按系列生产商品，使用抽象工厂区分	方便拓展：将同一系列的产品做绑定在一起	
	建造者模式	当建造对象比较复杂时	促销活动逻辑/创建一个促销套餐的业务流程	
	单例模式	保证一个类仅有一个实例，并提供一个访问他的全局访问点/对静态实例的初始化：有两种饿汉式与懒汉式	保证账本有且只有一个/饿汉式	
	适配器模式	OrangeBagAdapter(适配器)	特例异常情况会用（亡羊补牢的补救措施）	6种结构型模式
	桥接模式	把两个属性类型分离在桥接使用（将两个维度变化的功能组合起来，为的是独立变化。）	需要先确定采摘的大小和材质（初始设计时使用）	
	装饰器模式	希望在不影响业务主流的前提下，在打包环节增加防伪/加固/加急等功能（动态地给一个对象增加一些额外的职责，为的时功能增强）	打包时附加动作的处理，比如加急标志	
	代理模式	一个类代表另一个类的功能	第三方类难获取到或者要隔离屏蔽	
	组合模式	把一组相似的对象当作一个单一的对象，为的时减少数据类型。		
	外观模式	糅合功能，对外只提供一个入口	调用方只关注facede组件，不需要知道底层服务2.隐藏掉底层服务中，不相干的功能	
	模板方法模式	在父类种编排主流程，将步骤实现延迟到子类去实现		6种行为型模式
	策略模式	通过选择策略类，来执行不同的算法分支，核心是通过注入对象，改变行为	Spring IOC思想	
	责任链模式	将请求传给一个接收者链，有链将请求流转给目标对象（当出现多个对象可以处理同一个请求时，适合责任链模式）	每个订单，可以用多个优惠卷	
	观察者模式	一个对象状态改变时通知其他对象	一个对象状态改变时通知其他对象。为的是尽量弱化对象间的依赖	
  命令模式	通过增加Command抽象命令类，将不符合抽象编程的Handler调用，转为抽象编程	执行对象Handler没有抽象接口，ListView直接使用Handler耦合性太大，新增一个Command接口	
	访问者模式	何为双重分派（利用双重分派机制，来弥补Java多态中的方法重载是静态化的不足）	理解比较复杂的模式	
![image](https://user-images.githubusercontent.com/34831488/198858849-eef9eb90-1653-4bbe-a8cc-05c58c612d19.png)

